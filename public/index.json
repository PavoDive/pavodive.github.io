[{"content":"Merging tables is one of the most common tasks when analyzing data. And yet, I always seem to forget how joins (merges) are done in pandas üêº. So here‚Äôs a reminder for future me (and apparently for you, if you happened to land here üòâ).\nMerging with Pandas Our Base DataFrame import pandas as pd items = { \u0026#34;color\u0026#34;: [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;white\u0026#34;], \u0026#34;price\u0026#34;: [50, 1200, 3, 40, 2], \u0026#34;date_created\u0026#34;: [\u0026#34;1999-10-30 05:00:00\u0026#34;, \u0026#34;2002-08-21 08:23:00\u0026#34;, \u0026#34;2003-05-15 14:19:00\u0026#34;, \u0026#34;2006-11-29 11:21:00\u0026#34;, \u0026#34;2018-02-12 23:23:00\u0026#34;], \u0026#34;sku\u0026#34;: [\u0026#34;1999-ROS-01\u0026#34;, \u0026#34;2002-SKY-01\u0026#34;, \u0026#34;2003-YOL-03\u0026#34;, \u0026#34;2006-EBO-01\u0026#34;, \u0026#34;2018-SNO-03\u0026#34;] } items_df = pd.DataFrame(items) Joining (Merging) Two Pandas DataFrames Now, let‚Äôs merge (join) two dataframes using pandas. For this, we‚Äôll create a dummy sales dataframe to compare with the one we already have. To illustrate the different types of joins, I‚Äôve added a new SKU in the sales dataframe that doesn‚Äôt exist in items_df. I‚Äôve also named the column sku_sales to demonstrate that the key columns in the two tables can have different names.\nYou‚Äôll notice that I‚Äôm using pd.merge instead of pd.join. That‚Äôs because pd.join performs joins on indexes, whereas the more flexible pd.merge can join on columns.\nsales = pd.DataFrame({ \u0026#34;sku_sales\u0026#34;: [\u0026#34;1999-ROS-01\u0026#34;, \u0026#34;2018-SNO-03\u0026#34;, \u0026#34;2020-NAN-01\u0026#34;, \u0026#34;2006-EBO-01\u0026#34;], \u0026#34;qty_sold\u0026#34;: [100, 5, 7, 24] }) Left Join: All Items in Sales A left join includes all rows from the sales dataframe. If a row in sales does not match a row in items_df (based on the join key), you‚Äôll get NaN values for the unmatched columns. This means that we‚Äôll see all items in sales, but we won‚Äôt have information about items in items_df that didn‚Äôt sell.\nmerged_left = pd.merge(sales, items_df, left_on=\u0026#34;sku_sales\u0026#34;, right_on=\u0026#34;sku\u0026#34;, how=\u0026#34;left\u0026#34; ) print(merged_left) # sku_sales qty_sold color price date_created sku # 0 1999-ROS-01 100 red 50.0 1999-10-30 05:00:00 1999-ROS-01 # 1 2018-SNO-03 5 white 2.0 2018-02-12 23:23:00 2018-SNO-03 # 2 2020-NAN-01 7 NaN NaN NaN NaN # 3 2006-EBO-01 24 black 40.0 2006-11-29 11:21:00 2006-EBO-01 Tip: For both left and right joins, you may want to drop one of the duplicated key columns (sku_sales or sku). If you can‚Äôt remember how to drop a column (like me!), check this post.\nRight Join: All Items in items_df A right join includes all rows from the items_df dataframe. In this case, you‚Äôll lose information about sales rows that don‚Äôt match. For example, the 2020-NAN-01 item is not included in the result because it doesn‚Äôt exist in items_df.\nmerged_right = pd.merge(sales, items_df, left_on=\u0026#34;sku_sales\u0026#34;, right_on=\u0026#34;sku\u0026#34;, how=\u0026#34;right\u0026#34; ) print(merged_right) # sku_sales qty_sold color price date_created sku # 0 1999-ROS-01 100.0 red 50 1999-10-30 05:00:00 1999-ROS-01 # 1 NaN NaN blue 1200 2002-08-21 08:23:00 2002-SKY-01 # 2 NaN NaN yellow 3 2003-05-15 14:19:00 2003-YOL-03 # 3 2006-EBO-01 24.0 black 40 2006-11-29 11:21:00 2006-EBO-01 # 4 2018-SNO-03 5.0 white 2 2018-02-12 23:23:00 2018-SNO-03 Outer Join (Union): Items from Both DataFrames Outer joins include all rows from both dataframes. If an item appears in only one of the dataframes, the unmatched columns will contain NaN values.\nmerged_outer = pd.merge(sales, items_df, left_on=\u0026#34;sku_sales\u0026#34;, right_on=\u0026#34;sku\u0026#34;, how=\u0026#34;outer\u0026#34; ) print(merged_outer) # sku_sales qty_sold color price date_created sku # 0 1999-ROS-01 100.0 red 50.0 1999-10-30 05:00:00 1999-ROS-01 # 1 NaN NaN blue 1200.0 2002-08-21 08:23:00 2002-SKY-01 # 2 NaN NaN yellow 3.0 2003-05-15 14:19:00 2003-YOL-03 # 3 2006-EBO-01 24.0 black 40.0 2006-11-29 11:21:00 2006-EBO-01 # 4 2018-SNO-03 5.0 white 2.0 2018-02-12 23:23:00 2018-SNO-03 # 5 2020-NAN-01 7.0 NaN NaN NaN NaN Inner Join (Intersection): Items in Both sales and items_df An inner join creates a new dataframe containing only the rows that exist in both dataframes (based on the join key).\nmerged_inner = pd.merge(sales, items_df, left_on=\u0026#34;sku_sales\u0026#34;, right_on=\u0026#34;sku\u0026#34;, how=\u0026#34;inner\u0026#34; ) print(merged_inner) # sku_sales qty_sold color price date_created sku # 0 1999-ROS-01 100 red 50 1999-10-30 05:00:00 1999-ROS-01 # 1 2018-SNO-03 5 white 2 2018-02-12 23:23:00 2018-SNO-03 # 2 2006-EBO-01 24 black 40 2006-11-29 11:21:00 2006-EBO-01 Cross Join: The Cartesian Product of Both DataFrames A cross join might be useful in certain edge cases (though not for this example). It produces the Cartesian product of the two dataframes, meaning every row in sales is combined with every row in items_df. Notice that left_on and right_on are not needed for this operation.\nmerged_cross = pd.merge(sales, items_df, how=\u0026#34;cross\u0026#34; ) print(merged_cross) # sku_sales qty_sold color price date_created sku # 0 1999-ROS-01 100 red 50 1999-10-30 05:00:00 1999-ROS-01 # 1 1999-ROS-01 100 blue 1200 2002-08-21 08:23:00 2002-SKY-01 # 2 1999-ROS-01 100 yellow 3 2003-05-15 14:19:00 2003-YOL-03 # 3 1999-ROS-01 100 black 40 2006-11-29 11:21:00 2006-EBO-01 # 4 1999-ROS-01 100 white 2 2018-02-12 23:23:00 2018-SNO-03 # 5 2018-SNO-03 5 red 50 1999-10-30 05:00:00 1999-ROS-01 # 6 2018-SNO-03 5 blue 1200 2002-08-21 08:23:00 2002-SKY-01 # 7 2018-SNO-03 5 yellow 3 2003-05-15 14:19:00 2003-YOL-03 # 8 2018-SNO-03 5 black 40 2006-11-29 11:21:00 2006-EBO-01 # 9 2018-SNO-03 5 white 2 2018-02-12 23:23:00 2018-SNO-03 # 10 2020-NAN-01 7 red 50 1999-10-30 05:00:00 1999-ROS-01 # 11 2020-NAN-01 7 blue 1200 2002-08-21 08:23:00 2002-SKY-01 # 12 2020-NAN-01 7 yellow 3 2003-05-15 14:19:00 2003-YOL-03 # 13 2020-NAN-01 7 black 40 2006-11-29 11:21:00 2006-EBO-01 # 14 2020-NAN-01 7 white 2 2018-02-12 23:23:00 2018-SNO-03 # 15 2006-EBO-01 24 red 50 1999-10-30 05:00:00 1999-ROS-01 # 16 2006-EBO-01 24 blue 1200 2002-08-21 08:23:00 2002-SKY-01 # 17 2006-EBO-01 24 yellow 3 2003-05-15 14:19:00 2003-YOL-03 # 18 2006-EBO-01 24 black 40 2006-11-29 11:21:00 2006-EBO-01 # 19 2006-EBO-01 24 white 2 2018-02-12 23:23:00 2018-SNO-03 ","permalink":"https://pavodive.github.io/posts/merge_pandas_operations/","summary":"\u003cp\u003eMerging tables is one of the most common tasks when analyzing data. And yet, I always seem to forget how joins (merges) are done in pandas üêº. So here‚Äôs a reminder for future me (and apparently for you, if you happened to land here üòâ).\u003c/p\u003e","title":"Basic Merge Pandas Operations"},{"content":"There are some operations with pandas that I often forget. This site exists exactly for that: to remind me how to perform these tasks. In this post, I‚Äôll cover some very basic pandas operations that I often forget, including dropping columns, reordering columns, and changing the names of columns.\nPandas I won‚Äôt waste time explaining pandas üêº, the powerful Python library for data processing. Pandas can handle many complex operations and is a must-have tool for anyone working with data.\nAt the time of writing this, I am much more proficient with R than pandas, which might explain why I repeatedly forget these simple operations.\nOur Base DataFrame import pandas as pd items = { \u0026#34;color\u0026#34;: [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;white\u0026#34;], \u0026#34;name\u0026#34;: [\u0026#34;rose\u0026#34;, \u0026#34;sky\u0026#34;, \u0026#34;yolk\u0026#34;, \u0026#34;ebony\u0026#34;, \u0026#34;snow\u0026#34;], \u0026#34;price\u0026#34;: [50, 1200, 3, 40, 2], \u0026#34;date_created\u0026#34;: [\u0026#34;1999-10-30 05:00:00\u0026#34;, \u0026#34;2002-08-21 08:23:00\u0026#34;, \u0026#34;2003-05-15 14:19:00\u0026#34;, \u0026#34;2006-11-29 11:21:00\u0026#34;, \u0026#34;2018-02-12 23:23:00\u0026#34; ], \u0026#34;useless_column\u0026#34;: [\u0026#34;data\u0026#34;, \u0026#34;data\u0026#34;, \u0026#34;data\u0026#34;, \u0026#34;data\u0026#34;, \u0026#34;data\u0026#34;], \u0026#34;id\u0026#34;: [\u0026#34;1999-ROS-01\u0026#34;, \u0026#34;2002-SKY-01\u0026#34;, \u0026#34;2003-YOL-03\u0026#34;, \u0026#34;2006-EBO-01\u0026#34;, \u0026#34;2018-SNO-03\u0026#34; ] } items_df = pd.DataFrame(items) Our base dataframe is a simple table containing miscellaneous data about items. There‚Äôs even an unnecessary column, which we‚Äôll remove shortly.\nDropping Columns Let‚Äôs get rid of the useless column. The inplace=True parameter is self-explanatory: it removes the column in place rather than returning a new object. This way, the original dataframe is directly updated.\nitems_df.drop(columns=[\u0026#34;useless_column\u0026#34;], inplace=True) Reordering Columns Sometimes, I need to export dataframes to tables or CSV files where the ordering of columns matters for end users. Reordering columns is as simple as passing a list of column names in the desired order:\nname_order = [\u0026#34;id\u0026#34;, \u0026#34;date_created\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;color\u0026#34;, \u0026#34;price\u0026#34;] items_df = items_df[name_order] Changing the Names of Columns Another operation I often need is renaming columns. To rename columns, pass a dictionary in the format {\u0026quot;old_name\u0026quot;: \u0026quot;new_name\u0026quot;} to the rename method.\nitems_df.rename(columns={\u0026#34;id\u0026#34;: \u0026#34;sku\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;Color\u0026#34;}, inplace=True) ","permalink":"https://pavodive.github.io/posts/basic_pandas_operations/","summary":"\u003cp\u003eThere are some operations with pandas that I often forget. This site exists exactly for that: to remind me how to perform these tasks. In this post, I‚Äôll cover some very basic pandas operations that I often forget, including dropping columns, reordering columns, and changing the names of columns.\u003c/p\u003e","title":"Basic Pandas Operations"},{"content":"Dates and date-time objects are some of the most challenging data types to work with. They can come in a variety of formats (long live ISO 8601!), may have different time zones, and introduce considerable complexity as a result.\nAside from variations in format, such discrepancies can cause massive issues:\nMoreover, time zones add yet another layer of potential confusion. Let‚Äôs see how pandas üêº handles this.\nOur Base DataFrame import pandas as pd items = { \u0026#34;name\u0026#34;: [\u0026#34;rose\u0026#34;, \u0026#34;sky\u0026#34;, \u0026#34;yolk\u0026#34;, \u0026#34;ebony\u0026#34;, \u0026#34;snow\u0026#34;], \u0026#34;price\u0026#34;: [50, 1200, 3, 40, 2], \u0026#34;date_created\u0026#34;: [\u0026#34;1999-10-30 05:00:00\u0026#34;, \u0026#34;2002-08-21 08:23:00\u0026#34;, \u0026#34;2003-05-15 14:19:00\u0026#34;, \u0026#34;2006-11-29 11:21:00\u0026#34;, \u0026#34;2018-02-12 23:23:00\u0026#34; ], } items_df = pd.DataFrame(items) Converting Strings to Dates in Pandas Let‚Äôs check how pandas interprets the data types in our dataframe:\nprint(items_df.dtypes) # Output: # name object # price int64 # date_created object As we can see, the date_created column is treated as an object (likely because it contains strings). To handle it as a date-time, we must convert it:\nitems_df[\u0026#34;date_created\u0026#34;] = pd.to_datetime(items_df[\u0026#34;date_created\u0026#34;]) print(items_df.dtypes) # Output: # name object # price int64 # date_created datetime64[ns] Now the date_created column is properly processed as datetime64[ns].\nFiltering a DataFrame by a Date Pandas‚Äô handling of dates and times remains a bit mysterious to me. I understand that dates and times are inherently complex, but pandas\u0026rsquo; behavior can sometimes feel confusing. For instance, consider this Stack Overflow question and Quant‚Äôs detailed answer. While the diagram isn‚Äôt perfectly up-to-date (as of 2025-01-19), it‚Äôs still quite relevant and demonstrates the complexity involved!\nHere‚Äôs one such surprising behavior:\nWhile our date_created column shows a type of datetime64[ns], attempting to access its individual elements reveals something slightly different:\nprint(type(items_df[\u0026#34;date_created\u0026#34;].iloc[1])) # Output: \u0026lt;class \u0026#39;pandas._libs.tslibs.timestamps.Timestamp\u0026#39;\u0026gt; When we try to filter this column using a simple string date, pandas automatically coerces the string to a date, and the operation works as expected:\nstart_date_1 = \u0026#34;2000-01-01\u0026#34; filtered_items_1 = items_df[items_df[\u0026#34;date_created\u0026#34;] \u0026gt;= start_date_1] print(filtered_items_1) However, if the string includes both a time and a time zone, pandas no longer performs automatic coercion, causing the operation to fail:\nstart_date_2 = \u0026#34;2000-01-01 00:00:00-05:00\u0026#34; try: filtered_items_2 = items_df[items_df[\u0026#34;date_created\u0026#34;] \u0026gt;= start_date_2] except Exception as e: print(e) filtered_items_2 = \u0026#34;Nothing to see here\u0026#34; finally: print(filtered_items_2) # Output: # Invalid comparison between dtype=datetime64[ns] and str # Nothing to see here Pandas, perhaps cautiously, avoids coercion in this case, leaving the responsibility to us. Let‚Äôs fix this manually by converting the string to a timestamp using the same method we used earlier:\nstart_date_2 = pd.to_datetime(start_date_2) print(type(start_date_2) == type(items_df[\u0026#34;date_created\u0026#34;].iloc[1])) # Output: True # Both are \u0026lt;class \u0026#39;pandas._libs.tslibs.timestamps.Timestamp\u0026#39;\u0026gt; At this point, the two values appear to be of the same type, but they still can‚Äôt be compared:\ntry: items_df[\u0026#39;date_created\u0026#39;].iloc[1] \u0026gt; start_date_2 except Exception as e: print(e) finally: pass # Output: # Cannot compare tz-naive and tz-aware timestamps The error occurs because one value is timezone-naive (lacking information about the time zone), and the other is timezone-aware. To proceed, we must convert one of them to match the other.\nSolution 1: Convert start_date_2 to Timezone-Naive start_date_naive = start_date_2.tz_localize(None) try: filtered_items_2 = items_df[items_df[\u0026#34;date_created\u0026#34;] \u0026gt;= start_date_naive] except Exception as e: print(e) filtered_items_2 = \u0026#34;Nothing to see here\u0026#34; finally: print(filtered_items_2) # The filtering succeeds! ü•≥ Solution 2: Convert items_df[\u0026quot;date_created\u0026quot;] to Timezone-Aware # Create a new column (optional) items_df[\u0026#34;new_date_created\u0026#34;] = items_df[\u0026#34;date_created\u0026#34;].dt.tz_localize(\u0026#34;America/Bogota\u0026#34;) # Now we can compare against our original timezone-aware variable try: filtered_items_2 = items_df[items_df[\u0026#34;new_date_created\u0026#34;] \u0026gt;= start_date_2] except Exception as e: print(e) filtered_items_2 = \u0026#34;Nothing to see here\u0026#34; finally: print(filtered_items_2) # It works! ü•≥ A key insight here is the .dt accessor, which acts as a gateway to apply date-time operations on pandas Series. According to the documentation, the .dt accessor \u0026ldquo;returns a Series indexed like the original Series. Raises TypeError if the Series does not contain datetimelike values.\u0026rdquo; This is essential because tz_localize operates on datetime objects, not directly on Series (thanks wordsforthewise for the hint!).\nDates and times can be tricky, but pandas provides powerful tools to manage them. With some care and awareness of datetime intricacies, you‚Äôll master these challengesin no time! üêº\n","permalink":"https://pavodive.github.io/posts/time_pandas_operations/","summary":"\u003cp\u003eDates and date-time objects are some of the most challenging data types to work with. They can come in a variety of formats (long live \u003ca href=\"https://en.wikipedia.org/wiki/ISO_8601\"\u003eISO 8601\u003c/a\u003e!), may have different time zones, and introduce considerable complexity as a result.\u003c/p\u003e","title":"Basic Time Pandas Operations"},{"content":"In legal documents in Spanish language it is often necessary to include the \u0026ldquo;value in words\u0026rdquo; of a number‚Äîfor example, $2400 (dos mil cuatrocientos pesos). I created the package spanish2 to automate this task. If you are curious to learn more about this package, please keep reading. If you\u0026rsquo;d like to install it or view its code, you can access its GitHub repository. Writing this package inspired this article about how to write an R package using Emacs and ESS (Emacs Speaks Statistics). You might want to check it out!\nWhy Write the Value in Words? I\u0026rsquo;m not sure if this is just a custom in my home country üá®üá¥, but in Colombia, it is common practice to include the value in words immediately after its numeric representation in legal documents. For example:\n\u0026hellip;con un precio de $1.000.000 (un mill√≥n de pesos)\u0026hellip;\nor\n\u0026hellip;el lote tiene un √°rea de 43 ha (cuarenta y tres hect√°reas)\u0026hellip;\nOver the past few months, I encountered this requirement repeatedly in the context of some ongoing collaborations.\nWhat alternatives did I have? There is a package in CRAN and in github called spanish that almost met my needs. This package provides a function, spanish::to_words(), for converting numbers into text. However, the function presented some limitations.\nFirst Issue: Incorrect Number Representation In certain cases, the package generated incorrect word representations for numbers. For instance:\n1 2 spanish::to_words(40000000) # \u0026#34;cuarenta millones mil \u0026#34; I managed to identify and suggest fixes for some of these issues, but additional errors emerged under less-than-ideal circumstances‚Äîsuch as when I had already delivered a finished document to a client. üòµ\nSecond Issue: Limited Range Another significant limitation of the package was that it could not handle numbers larger than 999,999,999.\nCreating a Solution: spanish2 Faced with these challenges, I decided to create my own solution. There\u0026rsquo;s nothing better than standardizing solutions you find helpful for yourself, as there\u0026rsquo;s a good chance others might find them useful as well. This is how the spanish2 package was born.\nImportant Note: While the spanish package did not meet my specific needs for this task, it offers several unique and valuable functions. For example, to_number() converts text-based numbers back into numeric values, and the package also includes functionality related to geolocation in Spain. If these features sound interesting, I encourage you to give the spanish package a try!\nSolution Strategy To convert numbers into words, I followed the same logical principle we use when reading numbers in Spanish:\nGroup the digits in sets of three, from right to left. Read these groups as \u0026ldquo;hundreds\u0026rdquo; (this concept was key‚Äîbear with me üòâ). Combine the different \u0026ldquo;hundred\u0026rdquo; blocks. Finally, clean the resulting text. Group Digits in Threes and Read Them as \u0026ldquo;Hundreds\u0026rdquo; The first task involves converting the number into a string and splitting it into groups of three digits. We use a regular expression (regex) to accomplish this:\ngroups = regmatches(y, gregexpr(\u0026#34;.{1,3}(?=(.{3})*$)\u0026#34;, y, perl = TRUE))[[1]] Once the number is split into groups of three digits, we pass each group to the function convert_3_digits. This function is responsible for \u0026ldquo;reading\u0026rdquo; the hundreds, tens, and units:\n1 2 3 4 5 6 7 8 9 10 convert_3_digits = function(string_value){ units = c(\u0026#34;cero\u0026#34;, \u0026#34;uno\u0026#34;, \u0026#34;dos\u0026#34;, \u0026#34;tres\u0026#34;, \u0026#34;cuatro\u0026#34;, \u0026#34;cinco\u0026#34;, \u0026#34;seis\u0026#34;, \u0026#34;siete\u0026#34;, \u0026#34;ocho\u0026#34;, \u0026#34;nueve\u0026#34;) string_value = sprintf(\u0026#34;%03d\u0026#34;, as.integer(string_value)) digits = strsplit(string_value, \u0026#34;\u0026#34;)[[1]] a = sapply(digits, function(x) units[as.integer(x) + 1]) raw_text = mapply(paste0, a, c(\u0026#34;cientos\u0026#34;, \u0026#34;diez y\u0026#34;, \u0026#34;\u0026#34;)) clean_text(paste(raw_text, collapse = \u0026#34; \u0026#34;)) } Here‚Äôs what is happening in detail:\nThe sapply function converts each digit into its corresponding word. For example, 234 becomes c(\u0026quot;dos\u0026quot;, \u0026quot;tres\u0026quot;, \u0026quot;cuatro\u0026quot;). The mapply function maps this vector of words to another vector specifying hundreds, tens, and units. This results in \u0026quot;dos cientos tres diez y cuatro\u0026quot;. Finally, the function clean_text handles edge cases such as \u0026ldquo;tres diez\u0026rdquo; (which should become \u0026ldquo;treinta\u0026rdquo;) to ensure the text is properly formatted. Map the Big Units At this point, we have the number converted into text groups of three. For instance, the number 1,234,567 would be converted into c(\u0026quot;cero cientos cero diez y uno\u0026quot;, \u0026quot;dos cientos tres diez y cuatro\u0026quot;, \u0026quot;cinco cientos seis diez y siete\u0026quot;).\nClearly, this output doesn‚Äôt quite make sense. To address this, we need to map each group to its corresponding \u0026ldquo;big units\u0026rdquo; (i.e., thousands or millions).\nThe second group (from right to left) represents thousands (mil), and the third group corresponds to millions (millones). After applying mapply, the text becomes \u0026ldquo;cero cientos cero diez y uno millones dos cientos tres diez y cuatro mil cinco cientos seis diez y siete\u0026rdquo;. While it may still look rough, the structure is now correct.\nClean the Text In the final step, we use the gsub function extensively to clean up the text. This involves applying regular expression replacements to handle edge cases and improve readability. Here‚Äôs what we do:\nRemove unnecessary elements: For example, \u0026ldquo;cero cientos\u0026rdquo; and \u0026ldquo;cero diez y\u0026rdquo; should be removed entirely, as they are redundant. Fix special pronunciations: Certain phrases like \u0026ldquo;diez y cinco\u0026rdquo; are replaced with their proper counterparts (e.g., \u0026ldquo;diez y cinco\u0026rdquo; becomes \u0026ldquo;quince,\u0026rdquo; and \u0026ldquo;diez y tres\u0026rdquo; becomes \u0026ldquo;trece\u0026rdquo;). What We Achieved The function spanish2::to_words() can convert numbers up to 1e22 or strings with numeric values up to 60 characters in length. Those are really big numbers!\nThe conversion to text adheres to the conventions of the Spanish language, specifically using the long scale. As a result, the number 1e9 (1,000,000,000) is converted to \u0026ldquo;mil millones\u0026rdquo;, not \u0026ldquo;un bill√≥n\u0026rdquo;, which may be the expectation of English speakers who are used to the short scale.\nAdditionally, the conversion produces the most standard and simple way of expressing a number in Spanish, even though alternative representations may exist. Here\u0026rsquo;s a comparison of some examples:\nNumber Common Style 1 Other Styles spanish2 Output 77 Setenta y siete setenta y siete 16 Diecis√©is Diez y seis diez y seis 27 Veintisiete Veinte y siete veinte y siete 1100 Mil cien Mil ciento / mil y ciento mil cien I hope this package proves to be useful to you! If it does, how about giving it a ‚≠ê on GitHub? üòä\nStar the repository on GitHub ‚≠ê\n","permalink":"https://pavodive.github.io/posts/spanish2/","summary":"\u003cp\u003eIn legal documents in Spanish language it is often necessary to include the \u0026ldquo;value in words\u0026rdquo; of a number‚Äîfor example, $2400 (dos mil cuatrocientos pesos). I created the package \u003ccode\u003espanish2\u003c/code\u003e to automate this task. If you are curious to learn more about this package, please keep reading. If you\u0026rsquo;d like to install it or view its code, you can access its \u003ca href=\"https://github.com/pavodive/spanish2\"\u003eGitHub repository\u003c/a\u003e. Writing this package inspired \u003ca href=\"https://pavodive.github.io/posts/writing-r-package-emacs/\" title=\"Writing an R package with Emacs\u0026#39; ESS\"\u003ethis article\u003c/a\u003e about how to write an R package using Emacs and ESS (Emacs Speaks Statistics). You might want to check it out!\u003c/p\u003e","title":"Paquete spanish2 para R"},{"content":"This article provides a step-by-step guide to writing R packages using Emacs\u0026rsquo; ESS (Emacs Speaks Statistics) mode. By the end, you\u0026rsquo;ll have created a simple package called dummyaddition, which can perform the simple task of adding two numbers or paste two strings.\nWhy Emacs? Emacs is one of those pieces of software that has stood the test of time. While some may argue that its age is a disadvantage, I would say that the fact it remains relevant after more than 40 years is proof of its robust design and adaptability to modern needs.\nIt‚Äôs far more than just a text editor or an IDE‚Äîit‚Äôs a powerful tool that has allowed me to develop a highly efficient workflow.\nHere are some reasons why I prefer Emacs:\nKeyboard-Centric Efficiency Emacs is command-line-based, meaning almost every possible action can be executed via the keyboard. I rarely use the mouse during my workflow. Relying on the mouse can strain your hands and arms, and it wastes time in unnecessary movements.\nExtensibility and Customization Emacs is incredibly extensible and highly customizable. Whether you prefer to keep it simple or turn it into a complex powerhouse, you can tweak it to fit your needs and fulfill your specific desires.\nEasy to Learn Although some people say the learning curve for Emacs is steep, I disagree. Vanilla (unmodified) Emacs is very simple to use, and it comes with excellent documentation. You can start by point-and-clicking while familiarizing yourself with the keyboard shortcuts. It‚Äôs not a radical difference from what you\u0026rsquo;re likely using now. Over time, you‚Äôll gradually learn to enhance and tailor Emacs to make it more efficient for your workflow.\nFree and Open Source Emacs is free‚Äîboth as in üç∫ (beer) and as in freedom. You can install it on any operating system at no cost. Not only do you not have to pay, but also nothing is taken from you: not your data, your software interactions, or your privacy.\nBeing open-source means you can modify Emacs and even share your tweaks with others‚Äîwithout anyone coming after you with legal concerns. It embodies true software freedom.\nWhy a Package? One of the fundamental goals of software development is automation. Tasks we do frequently should be made quicker and easier to execute. It\u0026rsquo;s a common scenario: you write a function once, then you need it again, and again\u0026hellip;\nInstead of rewriting the same function multiple times (trust me, I‚Äôve been there‚Äîit‚Äôs not fun), or wasting time searching for where you wrote it last, it‚Äôs better to consolidate those functions into a package. A package allows you to load and reuse those functions effortlessly whenever you need them.\nCreating a package also means you can share your functions with others who might be facing the same problem you solved. By writing packages, you‚Äôre contributing to a collaborative environment. After all, I‚Äôm sure you‚Äôve relied heavily on R packages created by others‚Äîso why not give back?\nEnd Result By following this step-by-step guide, you will create a new package called dummyaddition. This package, while basic, will demonstrate the essential steps involved in creating an R package. You‚Äôll host your version in your GitHub repository, but if you‚Äôd like to see mine for reference, here‚Äôs the link: dummyaddition.\nStep by Step Magit for Version Control Create a Repository on Github The first step is to create a new repository on your GitHub account. I\u0026rsquo;ve named mine dummyaddition, but feel free to choose a name that makes sense for your project. While filling out the description field is optional, I highly recommend doing so‚Äîit‚Äôs helpful to have a clear description for each repository.\nKeep in mind that the R package naming conventions (required by CRAN) allow only ASCII characters and numbers. Avoid using special characters like dashes, underscores, or periods in the name.\nYou also have the option to make the repository public or private. If you\u0026rsquo;re planning to share your code (which I strongly encourage), make the repository public.\nBefore creating the repository, configure the following minor but important settings:\nInitialize with a README.md: Check this box. We\u0026rsquo;ll use the README later. Add a .gitignore file: Select the R template. This ensures that Git ignores unnecessary files, such as .history, which don‚Äôt add value to your project. Choose a License: GitHub offers several license options. Two common ones are the MIT License and the GNU General Public License v3.0. Be sure to read about their differences, as they may affect how your software can be used. For this tutorial, I‚Äôve chosen the GNU General Public License v3.0. Additionally, check the licenses of the R packages you plan to use in your code. Some licenses require you to adopt compatible or less restrictive licenses for your package. Once you\u0026rsquo;ve configured the settings, click the Create Repository button.\nMagit Magit is an Emacs package that acts as a hybrid between a graphical Git client and the standard command-line Git interface. It provides user-friendly commands for Git actions. I use Magit because it simplifies interacting with Git, and I only need to remember a few basic commands. It‚Äôs user-friendly, and if you want to explore the actual Git commands it runs under the hood, they‚Äôre readily available for auditing and study.\nIf Git is not installed on your system, you can follow the official installation instructions here.\nAfter installing Git, configure your name and email to associate commits with your identity:\ngit config --global user.name \u0026#34;John Doe\u0026#34; git config --global user.email johndoe@example.com Next, install Magit for Emacs. If you haven‚Äôt installed it yet, I recommend doing so via MELPA, the Emacs package repository. Add the following lines to your .emacs file:\n(require \u0026#39;package) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) Select this block of text, evaluate it in Emacs by pressing M-x eval-region RET, and then refresh your package list with:\nM-x package-refresh-contents RET You can now install Magit (and its dependencies) by running:\nM-x package-install RET magit RET To ensure everything works as expected, restart your Emacs session. This resets the load-path and avoids potential issues with outdated configurations.\nCloning the Repository Now it\u0026rsquo;s time to clone the GitHub repository onto your computer.\nNavigate to the directory where you‚Äôd like to clone the repository. For example, if you\u0026rsquo;d like to clone it into ~/Documents, open Emacs‚Äô Dired mode with C-x D and enter ~/Documents/ to open the corresponding directory.\nNext, run the following command in Emacs:\nM-x magit-clone Magit will ask where you\u0026rsquo;d like to clone the repository from. Choose [u] for URL. Then, paste the repository URL from your GitHub page. You can find the URL by clicking the green \u0026ldquo;\u0026lt;\u0026gt; Code\u0026rdquo; button and copying the HTTPS URL. For example:\nhttps://github.com/PavoDive/dummyaddition.git Paste this URL into Magit‚Äôs minibuffer.\nMagit will then ask you to confirm the name of the subdirectory where the repository will be cloned. By default, it suggests the repository\u0026rsquo;s name (e.g., dummyaddition). I recommend keeping this to maintain consistency.\nIt will also ask, \u0026ldquo;Set remote.pushDefault to origin? (y or n)\u0026rdquo;. Since this is the start of a new repository, you can safely choose yes (y).\nAfter a short while, Magit will finish the cloning process and display a new buffer with the repository\u0026rsquo;s details and the most recent commit. You might need to press TAB to expand the details of the commits.\nTo verify the repository has been cloned, refresh the Dired buffer by pressing g. You should see a new directory‚Äîdummyaddition‚Äîinside your ~/Documents folder. Navigate to this directory, and you\u0026rsquo;ll find:\ndrwxrwxr-x 8 gp gp 4.0K Jan 11 17:44 .git -rw-rw-r-- 1 gp gp 671 Jan 11 17:44 .gitignore -rw-rw-r-- 1 gp gp 35K Jan 11 17:44 LICENSE -rw-rw-r-- 1 gp gp 26 Jan 11 17:44 README.md These include the files and folders created during the GitHub setup:\n.gitignore: Preconfigured to ignore unnecessary files. LICENSE: The license you selected during setup. README.md: The initial README file. .git/: A hidden directory containing version control metadata. Ready to Start Developing You are now ready to start developing your R package! üéâ\nRequired Packages To make writing R packages easier and more efficient, we need to install two essential packages:\nrmarkdown: Converts R Markdown documents into various formats. devtools: A collection of package development tools‚Äîa package to help you develop packages! If these aren\u0026rsquo;t installed yet, start a new R session in your Documents directory by running M-x R in Emacs. Once the R session starts, enter the following commands:\ninstall.packages(\u0026#34;rmarkdown\u0026#34;) install.packages(\u0026#34;devtools\u0026#34;) These packages may require additional dependencies. Since the installation process varies depending on your system, you might encounter errors. If so, don‚Äôt worry! Take a deep breath, search for the errors, and troubleshoot any issues you encounter.\nKeep Calm and Try Again\nAfter successfully installing the packages, load them in your R session:\nlibrary(rmarkdown) library(devtools) Create a Package Now that we‚Äôve set up the necessary tools, let\u0026rsquo;s create the package. In your R session, run:\ncreate(\u0026#34;dummyaddition\u0026#34;) This will create a new R package named dummyaddition, inside a corresponding dummyaddition directory.\n‚ö† Important Note: Ensure that your R session is not inside the dummyaddition directory when running devtools::create. Otherwise, it will attempt to create a nested package (e.g., a dummyaddition folder inside another dummyaddition folder), which can be problematic.\nWhen executed, the function prints the following information in your R console:\n‚úî Setting active project to \u0026#34;/home/gp/Documents/dummyaddition\u0026#34;. ‚úî Creating R/. ‚úî Writing DESCRIPTION. Package: dummyaddition Title: What the Package Does (One Line, Title Case) Version: 0.0.0.9000 Authors@R (parsed): * First Last \u0026lt;first.last@example.com\u0026gt; [aut, cre] Description: What the package does (one paragraph). License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a license Encoding: UTF-8 Roxygen: list(markdown = TRUE) RoxygenNote: 7.3.2 ‚úî Writing NAMESPACE. ‚úî Setting active project to \u0026#34;\u0026lt;no active project\u0026gt;\u0026#34;. What Gets Created? You\u0026rsquo;ll notice the following new elements in your dummyaddition folder:\nDESCRIPTION: Describes the metadata of your package (e.g., name, author, version, and description). Edit this file following the instructions within it. NAMESPACE: Manages exported and imported functions. This file is automatically generated‚Äîavoid editing it manually. R/: A folder to store your package functions and code. Currently, it is empty. At this point, we have the skeleton of the package. Let‚Äôs move on to writing the code!\nWriting the Code Let\u0026rsquo;s define the core function of our package. Create a new file called addition.R inside the R/ directory and add the following code:\n1 2 3 4 5 6 7 8 9 10 addition \u0026lt;- function(a, b) { if (length(a) \u0026gt; 1 || length(b) \u0026gt; 1) { stop(\u0026#34;I can\u0026#39;t accept a vector. Sorry.\u0026#34;) } if (is.numeric(a) == TRUE \u0026amp;\u0026amp; is.numeric(b) == TRUE) { a + b }else { paste0(as.character(a), as.character(b)) } } Of course, your package can include multiple complex functions. As a general recommendation, place each exported function in its own file. It‚Äôs fine to include auxiliary (internal) functions inside the same file as the main function that uses them.\nDocumenting the Functions Documentation is a crucial aspect of package development, and with devtools, you can easily manage it using roxygen2. This involves placing special comments at the top of each function to describe its purpose, usage, and arguments.\nLet‚Äôs document our addition function by adding the following above its definition in addition.R:\n#\u0026#39; Add two numeric values or paste two character values. #\u0026#39; #\u0026#39; This function takes two single values and adds them, #\u0026#39; if they are numeric, or pastes them together, otherwise. #\u0026#39; The function checks the length of each argument, and #\u0026#39; returns an error if any of the arguments has length #\u0026#39; greater than one. #\u0026#39; #\u0026#39; @usage addition(a, b) #\u0026#39; @keywords addition, pasting, sum. #\u0026#39; @param a A single value that is numeric, character or that #\u0026#39; can be coerced to character. #\u0026#39; @param b A single value that is numeric, character or that #\u0026#39; can be coerced to character. #\u0026#39; @return A numeric value with the sum of a and b, if both #\u0026#39; are numeric, or a string if both values can be coerced to #\u0026#39; to string. #\u0026#39; @examples #\u0026#39; # Adding numerc values #\u0026#39; addition(1, 6) #\u0026#39; # Pasting strings together #\u0026#39; addition(\u0026#34;nice \u0026#34;, \u0026#34;function\u0026#34;) #\u0026#39; @export Key Points About Documentation: #' denotes a documentation comment. The @export tag is essential to make the function available to users of the package. Functions without this tag are treated as internal. Tags like @param, @return, @keywords, and @examples provide structured details about the function. A Note on Imports If your package relies on external libraries, you should include the @import tag in the documentation, like this:\n#\u0026#39; @import data.table This ensures the package correctly imports external functionality.\nWith the core function implemented and documented, you‚Äôre well on your way to building a functional R package. Great work so far! üéâ\nBuilding the Documentation To build the documentation for your package, ensure your working directory is set to the package\u0026rsquo;s root directory (dummyaddition). If you haven‚Äôt closed your R session, you can simply use:\nsetwd(\u0026#34;dummyaddition\u0026#34;) If you‚Äôve already closed the session, just start a new R session in the correct directory and reload the required libraries (devtools and rmarkdown) using library().\nNow, use the devtools::document() function, a convenient wrapper for the roxygen2::roxygenize() function, to generate the documentation. Run:\ndocument() This produces the following output:\n‚Ñπ Updating dummyaddition documentation ‚Ñπ Loading dummyaddition Writing NAMESPACE Writing addition.Rd Let\u0026rsquo;s break down what happens when you run this command:\nThe NAMESPACE file is updated automatically: it now includes the information needed to export the addition function. The man/ directory is created, if it doesn‚Äôt already exist. This folder contains documentation files for your exported functions, written in .Rd format. For example: addition.Rd: This file was generated from the special comments in the addition.R file. It contains documentation in a format recognized by R. Note: Do not modify this file directly, as it is automatically generated. At this point, you can now access the help for your function, even though the package isn‚Äôt installed yet. To do this, use a specific process:\n\u0026gt; ? + addition In this code:\n\u0026gt; represents the R prompt. + indicates a continuation line (a feature of Emacs). This means: write ? and when emacs offers you the continuation line, write addition.\nWhen you run this command, you‚Äôll see a nicely formatted help page for your function, rendered as if the package were fully installed:\n‚Ñπ Rendering development documentation for \u0026#34;addition\u0026#34; addition package:dummyaddition R Documentation Add two numeric values or paste two character values. Description: This function takes two single values and adds them, if they are numeric, or pastes them together, otherwise. The function checks the length of each argument, and returns an error if any of the arguments has length greater than one. Usage: addition(a, b) Arguments: a: A single value that is numeric, character or that can be coerced to character. b: A single value that is numeric, character or that can be coerced to character. Value: A numeric value with the sum of a and b, if both are numeric, or a string if both values can be coerced to to string. Examples: # Adding numerc values addition(1, 6) # Pasting strings together addition(\u0026#34;nice \u0026#34;, \u0026#34;function\u0026#34;) This confirms that your documentation is functioning correctly and your package is well-structured.\nA Beautiful pdf Let\u0026rsquo;s generate a nicely formatted PDF for our package‚Äîjust like the ones you see with well-established R packages.\nTo produce this PDF, you\u0026rsquo;ll need to use a shell (or Emacs‚Äô Eshell). Open a shell using M-x shell or M-x eshell and navigate to the parent directory of your project (Documents in this example). Then, run the following command in the shell:\nR CMD Rd2pdf dummyaddition This will generate a PDF file named dummyaddition.pdf in the Documents folder.\n‚ö† Important Note: You may need LaTeX and Pandoc installed on your system to successfully create the PDF. If they‚Äôre not already installed, search online for platform-specific installation instructions (and make yourself a coffee, installing them will require some time and patience).\nUpdate the README.md File The README.md file is the \u0026ldquo;face\u0026rdquo; of your package. It‚Äôs what people see first when they visit your repository (especially on GitHub), so it‚Äôs important to update it with relevant information.\nAt a minimum, your README.md file should include:\nWhat your package does: Provide a clear and simple explanation of what problem the package solves. How to install it: Include installation instructions. For example, you can add the following if your package is hosted on GitHub: devtools::install_github(\u0026#34;yourusername/dummyaddition\u0026#34;) Replace \u0026quot;yourusername\u0026quot; with your GitHub username and \u0026quot;dummyaddition\u0026quot; with your package name.\nPushing Your Updated Package to Github Once you\u0026rsquo;ve completed your code, documentation, and updates to your README.md, it‚Äôs time to push the changes to GitHub. Magit makes this process smooth and efficient.\nOpen the Magit buffer for your repository, typically titled magit: dummyaddition. If it\u0026rsquo;s not already open, you can activate it with the command:\nM-x magit-status Refresh the repository status by pressing g in the Magit buffer. You\u0026rsquo;ll see something like this:\nHead: main Initial commit Merge: origin/main Initial commit Push: origin/main Initial commit Untracked files (4) Unstaged changes (1) Recent commits You may expand specific sections (e.g., untracked files, unstaged changes, recent commits) by pressing TAB.\nStaging and Committing Changes Untracked files: When you expand the \u0026ldquo;Untracked files\u0026rdquo; section, you\u0026rsquo;ll see files like DESCRIPTION, NAMESPACE, and directories like man/ and R/. These are the new files we created during the development process.\nStage these changes by selecting the file or directory and pressing s (for stage). Staged files will now appear under the \u0026ldquo;Staged changes\u0026rdquo; section. Unstaged changes: You‚Äôll notice that the README.md file appears here because it was modified (not newly created). Stage these changes with s as well. Magit may ask if you\u0026rsquo;d like to stage all changes‚Äîpress y to confirm.\nOnce all changes are staged under the \u0026ldquo;Staged changes\u0026rdquo; section, commit them by pressing c (for commit). A menu will appear. Press c again to create the commit.\nWriting the Commit Message Once you start the commit process, a buffer will open for you to write your commit message. Commit messages should be meaningful and concise. For example:\nTitle: Clearly summarize the commit in one line. Body (optional): Add more details if necessary, especially if the changes are complex. Here‚Äôs an example commit message for our work:\nCode and Documentation Generated - Added the core function `addition`. - Created auto-generated documentation with roxygen2. - Updated the README.md file. After writing your commit message, save it and press C-c C-c to confirm and close the buffer.\nThis will update the Magit buffer, which may now say something like:\nUnmerged into origin/main (1) 56d6bd3 main Code and Documentation Generated This means your changes have been committed locally but not yet pushed to the GitHub repository.\nPushing to GitHub To push your changes to GitHub, press P (for push) in the Magit buffer. A menu will appear‚Äîpress p to push your changes to origin/main.\nMagit may ask for your GitHub credentials (username and password) if you haven‚Äôt configured them for SSH or token-based authentication. Enter the required information, and after a moment, the Magit buffer will reflect that the changes have been pushed:\nRecent commits 56d6bd3 origin/main Code and Documentation Generated 4b1b6c8 Initial commit At this point, your changes are live on GitHub. You can verify them by visiting your repository on GitHub.\nShare Your Package Your journey isn‚Äôt complete until you share your work! While this package may solve a particular problem for you, it‚Äôs likely someone else out there (out of the 8 billion people on Earth üåç) may face the same challenge in the future. Sharing your work could help them too.\nHere are some ways to share your package:\nPost about it on your social networks. Write a blog post about what it accomplishes. Share it on platforms such as Hacker News or Lobste.rs. Mention it in relevant forums or communities. Whichever method you choose, don‚Äôt forget to share your amazing work with the world!\n","permalink":"https://pavodive.github.io/posts/writing-r-package-emacs/","summary":"\u003cp\u003eThis article provides a step-by-step guide to writing R packages using Emacs\u0026rsquo; ESS (Emacs Speaks Statistics) mode. By the end, you\u0026rsquo;ll have created a simple package called \u003ccode\u003edummyaddition\u003c/code\u003e, which can perform the simple task of adding two numbers or paste two strings.\u003c/p\u003e","title":"Writing an R package with Emacs and ESS"}]